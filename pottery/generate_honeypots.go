package pottery

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"text/tabwriter"

	"github.com/noelw19/honeypot/db"
	"github.com/noelw19/honeypot/lib"
)

type Honeypots struct {
	TLS    *tls.Config
	pots   []*Honeypot
	Config *Config
	Logger log.Logger
	DB     db.Db
}

func (hp *Honeypots) Start() {
	db := db.Db{}
	db.Start()

	hp.GenerateConfig()
	hp.startup_checks()
	hp.createHoneyPots()
}

// checks certs dir and wordlists dir
func (hp *Honeypots) startup_checks() {
	// do MTLS Certificate check if child
	if hp.Config.HasParent() {

		if lib.FileExist("./certs") && lib.FileExist("./certs/ca/ca.crt") && lib.FileExist("./certs/ca/ca.key") && lib.FileExist("./certs/server/server.crt") && lib.FileExist("./certs/server/server.key") && lib.FileExist("./certs/client/client.crt") && lib.FileExist("./certs/client/client.key") {
			lib.MTLS_Verify_Certs(hp.Config.Parent, hp.Config.NamingScheme)
			tlsConfig := lib.LoadTLSConfig()
			hp.TLS = tlsConfig
		} else {
			log.Println(lib.RedLog("You have certificates missing for MTLS connectivity"))
			log.Fatalln(lib.RedLog("Make sure to copy the CA Certificate, and both the client key and client cert to the certs directory"))
		}
	}

	if hp.Config.IsParent() {
		// check to see if ca, server and client certs exist
		if lib.FileExist("./certs") && lib.FileExist("./certs/ca/ca.crt") && lib.FileExist("./certs/ca/ca.key") && lib.FileExist("./certs/server/server.crt") && lib.FileExist("./certs/server/server.key") && lib.FileExist("./certs/client/client.crt") && lib.FileExist("./certs/client/client.key") {
			// all exist continue
			tlsConfig := lib.LoadTLSConfig()
			hp.TLS = tlsConfig
			log.Println(lib.GreenLog("All MTLS certificates exist as expected... Continuing"))
		} else {
			// generate all certs
			lib.GenAll()
		}
	}

	if lib.FileExist("./wordlists") {
		// check if there are files within
		dir, err := os.ReadDir("./wordlists")
		if err != nil {
			log.Println(lib.RedLog("Error checking wordlist directory, you will need a wordlist directory in order for randomized dynamic endpoint creation"))
			os.Mkdir("./wordlists", 0777)

			// add autogenerated wordlist for startup
			log.Fatalln(lib.RedLog("./wordlists created you will need a wordlist in this directory to begin"))
		}
		if len(dir) == 0 {
			log.Fatalln(lib.RedLog("You will need a wordlist in the ./wordlists directory to begin"))
		}
	} else {
		os.Mkdir("./wordlists", 0777)
		lib.InitWordList()
	}
}

func (mod *Honeypots) printHoneypotsAndEndpoints() {
	for _, pot := range mod.pots {
		fmt.Println("\n\nPot Name: ", pot.Name, "\nPot Port: ", pot.Port)
		fmt.Println()
		for index, ep := range pot.Wordlist {
			fmt.Printf("%d. /%s\n", index+1, ep)
		}
	}
}

func (mod *Honeypots) createHoneyPots() {
	for n, port := range mod.Config.Ports {
		mod.pots = append(mod.pots, &Honeypot{
			DeviceIP: mod.Config.CurrentIP,
			Port:     port,
			Name:     fmt.Sprintf("%s-%d", mod.Config.NamingScheme, n),
			State:    "Not Running",
		})
	}

	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	fmt.Println("")

	w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
	fmt.Fprintln(w, "Port", "| Pots Fired")
	fmt.Fprintln(w, "-----", "----------")
	w.Flush()

	type honeyPotServers struct {
		servers   []*http.Server
		honeypots []string
	}
	srv := &honeyPotServers{}

	for _, pot := range mod.pots {
		potServer := pot.Run(10, mod.Config)

		go func() {
			potServer.ListenAndServe()
		}()

		// pot.State = "Running"
		srv.servers = append(srv.servers, potServer)
		srv.honeypots = append(srv.honeypots, pot.Name)
	}

	fmt.Fprintln(w, "-----", "----------")
	w.Flush()

	if mod.Config.Parent != "none" && mod.Config.IsParent() {
		lib.CreateMTLSServer("8443", mod.TLS)
	}

	mod.printHoneypotsAndEndpoints()

	fmt.Println("")
	log.Println("Waiting for Victims....")
	log.Println("")

	// graceful shutdown when CTRL-C
	<-sigs
	log.Println()
	log.Println("------- Shutting down Pottery -------")
	log.Println()

	for i, server := range srv.servers {
		ctx, cancel := context.WithCancel(context.Background())

		if err := server.Shutdown(ctx); err != nil {
			log.Println("error when shutting down the main server: ", err)
		} else {
			log.Println("Gracefully shutting down: ", srv.honeypots[i])
		}
		cancel()
	}
	log.Println()
}
